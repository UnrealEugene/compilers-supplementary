-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun infixParser (op) {
  [s (op), fun (l, op, r) {Binop (op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),

    exp = memo $ eta (expr ({[Left, map (infixParser, {"!!", "&&"})],
                             [Nona, map (infixParser, {"==", "!=", "<", "<=", ">", ">="})],
                             [Left, map (infixParser, {"+", "-"})],
                             [Left, map (infixParser, {"*", "/", "%"})]}, primary)),

    stmt = memo $ eta syntax (name=lident s[":="] expr=exp            {Assn (name, expr)} |
                              kSkip                                   {Skip}              |
                              kRead name=inbr[s("("), lident, s(")")] {Read (name)}       |
                              kWrite expr=inbr[s("("), exp, s(")")]   {Write (expr)}),
                              
    stmts = memo $ eta syntax (first=stmt s[";"] second=stmts {Seq (first, second)} |
                               stmt);

-- Public top-level parser
public parse = stmts;
             
